# 软件测试笔记

## 黑盒测试(Functional Test)

### 边界测试

**简介**：边界值测试是针对输入变量的有效输入范围的边界值，在进行边界测试的时候，需要对每个输入值进行 在有效输入范围内，在边界值上，在有效输入范围外的测试，并将每中情况排列组合行程多种最终的输入情况。

<a id="single"> </a>*单缺陷假设：失效**极少**是由 2 个（或更多）缺陷**同时**发生引起的*

- **健壮性测试**： 要考虑无效值的输入
- 最坏情况测试：不考虑单缺陷假设，考虑全部边界输入的组合
- 随机测试：即使完成了全部测试，也不能发现程序的全部错误，随机生成测试用例，保证每类输出至少有一个。

### 等价类测试

大概目的是把有着相同输出的输入值按照类别划分，减少同类的无意义测试用例。划分的种类主要有两种：有效等价类和无效等价类。

#### 有效等价类

有效等价类里都是有效的正确的输入，期待着有效正确的结果。具体的划分需要根据不同的问题和函数来考虑。

假定我们根据函数的输入 x, y 分别划分了等价类 N:3 种 M: 2 种，那么对于我们的测试，还会有若一般等价类和强一般等价类的区别

##### 弱一般等价类

基于单缺陷假设保证每个变量的每个等价类情况都覆盖到即可

![image-20190621161614405](http://ww2.sinaimg.cn/large/006tNc79ly1g49shq4a6hj30zu0cfdh8.jpg)

##### 强一般等价类

强一般等价类则要求覆盖到每一种分支情况

![image-20190621161752649](http://ww2.sinaimg.cn/large/006tNc79ly1g49shqjvkoj30uv0ldta2.jpg)

### 无效等价类

考虑不同的超过边界值的情况，再进行分类

#### 弱健壮等价类测试

基于单缺陷假设，测试数：取 N、M 的更大的一个再加无效值(**2  * 变量个数**)改进后

![image-20190621163551449](http://ww4.sinaimg.cn/large/006tNc79ly1g49shplw87j30mo0ewwfa.jpg)

#### 强等价类测试

多缺陷组合(笛卡尔积)

测试数 (M+2)*(N+2)

![image-20190621164144037](http://ww3.sinaimg.cn/large/006tNc79ly1g49shr1v4tj30lt0f075j.jpg)

### 基于决策表的测试

决策表的组成主要有四个部分：桩部分，条目部分，条件部分，行动部分。可以把条件看作输入，行动看作输出。

![image-20190621165025105](http://ww4.sinaimg.cn/large/006tNc79ly1g49shrh8ntj31kw0qx47p.jpg)

### 测试的效率

![image-20190621165251802](http://ww1.sinaimg.cn/large/006tNc79ly1g49shrvr43j317c0glabl.jpg)

软件测试的目标：使用尽可能少的测试用例，发现尽可能多的软件错误。

## 白盒测试

*程序图：节点表示语句片段，边表示控制流*

> 这里讲的是单元测试的部分

### 路径测试

#### DD-路径图(Decision to Decision)

将程序图中**相邻的**且**入度和出度都为 1** 的节点合并，即得DD-路径图

#### 测试覆盖指标

| 指标符号 | 覆盖名称      | 覆盖描述                                                     |
| -------- | ------------- | ------------------------------------------------------------ |
| C0       | 语句覆盖      | 是程序中每一可执行语句至少执行一次                           |
| C1       | 分支覆盖      | 使程序中的每个逻辑判断的取真取假分支至少经历一次             |
| C1P      | 条件覆盖      | 覆盖所有判断的每种分支                                       |
| Cmcc     | 多条件覆盖    | 使得每个判断表达式中条件的各种可能组合都至少出现一次         |
|          | 分支/条件覆盖 | 执行足够的测试用例，使得分支中每个条件取到各种可能的值，并使每个分支取到各种可能的结果。 |
| C∞       | 路径覆盖      | 路径测试就是设计足够多的测试用例，覆盖被测试对象中的所有可能路径 |

无论哪种测试覆盖，即使其覆盖率达到百分之百，都不能保证把所有隐藏的程序欠缺都揭露出来。

#### 圈复杂度

圈复杂度就直接数圈就好

<img src="http://ww1.sinaimg.cn/large/006tNc79ly1g494t1zcujj30f40hkq5d.jpg" style="zoom:45%" />

### 数据流测试

数据流测试关注的是数据，对数据的流向进行检测，得到 Def-use 路径。针对某变量找到所有 定义 和使用 的地方

| 定义：向内存地址写入值的语句 | 使用：向内存地址读取值的语句                           |
| ---------------------------- | ------------------------------------------------------ |
| 输入定义、赋值定义           | 谓词使用(判断)、计算使用、输出使用、定位使用、迭代使用 |

- 关于变量v的定义-使用路径(记做du-path)是PATHS (P)中的路径：使得对某个v∈V,存在定义节点DEF (v，m)和和使用节点USE (v，n),使得m和n是该路径的起始和终止节点。
- 关于变量 v 的定义清除路径：是具有**起始**和**终止**节点中的 Paths 中的路径，是的该路径中没有其他节点是 V 的定义节点。

|准则名称|准则定义|
|-|-|
|全定义准则|每个定义节点到一个使用的定义清除路径。|
|全使用准则|每个定义节点到所有使用节点以及后续节点的定义清除路径。|
|全谓词使用/部分计算使用准则|每个定义节点到所谓词使用的定义清除路径，若无谓词使用，至少有一个计算使用的定义清除路径。|
|全计算使用/部分谓词使用准则|每个定义节点到所有计算使用的定义清除路径，若无计算使用，至少有一个谓词使用的定义清除路径。|
|全定义使用路径准则|每个定义节点到所有使用节点以及后续节点的定义清除路径。包括有一次环路和或无环路的路径。|

### 测试的效率

![image-20190622114944598](http://ww2.sinaimg.cn/large/006tNc79ly1g49shnhcj2j314e0gitc3.jpg)

---

*前面黑盒和白盒里讲的一些主要是针对单一的程序或者单一的 function 的一个测试介绍（比如白盒就讲的是单元测试），关注的是如何对局部进行处理。而后面的更侧重对于整个软件系统应用前面的方法和思想设计一整套的测试。*

## 集成测试与系统测试

- 集成测试：需要了解程序的结构，是一种**结构化**的测试方法，有**路径覆盖**的含义。
- 系统测试：不需要了解程序的结构，是一种**黑盒**的测试方法，是**功能覆盖**的意义。
- 集成测试是由**软件开发人员**完成的;而系统测试往往是需要**用户的参与**的。

### 集成测试(白盒)

- 自顶向下集成：从主程序(顶层)开始,所有下层程序都以“桩程序”出现。完成顶层测试后，以真实程序代替桩程序，向下进行下一层测试。
- 桩程序：模拟被调用程序的代码，根据输出值返回相应的值，一般以表格形式存在。
- 自底向上集成：从程序的最下层节点(叶子)开始，通过编写“驱动器”完成测试，然后以真实程序代替“驱动器”向上进行上一层测试。
- 驱动器：模拟对测试节点的调用驱动
- 三明治集成：自顶向下和自底向上测试的组合，即同时从顶和底向中间层集成，可以减少桩程序和驱动的数量（你总数不还是那么多）。
- 大爆炸测试：不分层次，将所有单元放在一起编译，并进行一次性测试。

#### 基于调用图的集成

通过模块之间的关系的角度，得到程序的调用图

- 成对集成：为免除桩程序和驱动器的开发,可采用调用对的测试方法。成对测试集，就是调用图中边的数量。

- 相邻集成：为减少测试的数量，以相邻节点为集合，进行测试相邻节点:包括所有直接前驱和所有直接后继节点。除去叶子节点的所有节点的相邻集合。

#### 基于路径的集成

![](http://ww2.sinaimg.cn/large/006tNc79ly1g4a0zc3mt0j314a0i67a6.jpg)

![image-20190622164543228](http://ww3.sinaimg.cn/large/006tNc79ly1g4a11m030rj30xy0o444k.jpg)

<img src="http://ww2.sinaimg.cn/large/006tNc79ly1g49zrsex2ej30ky09c0t6.jpg" style="zoom:45%" />

MM-路径复杂度： V(G) = e(边数)-n(节点数)+2，**双向箭头表示两条边**

### 系统测试(黑盒)

原子系统功能(**ASF**)：在更宏观的角度去看一个程序，指在系统层可以观察得到的端口输入和输出事件的行动。软件是个人用的，所以院子系统功能其实是个人机交互的概念。人的操作(Input)，以及软件给人的反馈(Output)。开始于一个 Inpu，遍历一个或多个 MM 路径，以一个端口输出事件结束。

<img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4a6tpluzdj30j40pqtcv.jpg" style="zoom:45%" />

---

***专题性测试***

## 回归测试

软件发生了改变之后进行的测试。重新测试现有的功能，确定软件修改是否达到了**预期的目的**，**是否损害了原有的的正常功能**。**补充新的测试用例**来测试新的或被修改了的功能。

<table>
   <tr>
      <td>回归测试策略</td>
   </tr>
   <tr>
      <td>Version 1</td>
      <td>Version 2</td>
   </tr>
   <tr>
      <td>1. Develop P</td>
      <td>4.Modify Pto P'</td>
   </tr>
   <tr>
      <td>2.Test P</td>
      <td>5.Test P' for new functionality</td>
   </tr>
   <tr>
      <td>3. Release P</td>
      <td>6. Perform regression testing on P' to ensure that the code carried over from P behaves correctly</td>
   </tr>
   <tr>
      <td></td>
      <td>7. Release P'</td>
   </tr>
</table>

- **测试用例库**：将锁开发的测试用例保存到**测试用例库**中，进行维护和管理。
- **基线测试用例库**:当得到一个软件的基线版本时，用于基线版本测试的所有测试用例就形成了基线测试用例库

### 回归测试包的选择

- 再测试全部用例：风险最低，测试成本最高
- 基于风险选择测试：优先选择最重要的、关键的和可以的测试
- 基于操作剖面选择测试 **？**：测试用例是基于软件操作剖面开发的，优先选择那些针对最重要或最频繁使用功能的测试用例。
- 再测试修改的部分：通过等价性分析，识别软件的修改情况并分析修改的影响，将回归测试局限于被改变的模块和它的接口上。

### 回归测试步骤

1. 识别出软件中被修改的部分。
2. 从原基线测试用例库 T 中，排除所有不再适用的测试用例,确定那些对新的软件版本依然有效的测试用例，其结果是建立一个新的基线测试用例库T0。
3. 依据一定的策略从T0中选择测试用例测试被修改的软件。
4. 如果必要，生成新的测试用例集T1，用于测试T0无法充分测试的软件部分。
5. 用T1执行修改后的软件。
6. 第(2)和第(3)步测试， 验证修改是否破坏了现有的功能，第(4)和第(5)步测试验证修改工作本身。



**回归测试的代价**：目的是让 **分析和有选择的测试** 能够相比 **重新测试所有的** 花费更小。



### 用例选择方法

##### Overview

CFG(Control Flow Graph)

1. 找出 P 的原测试集中每一个测试用例的 execution trace。
2. 在 P 的控制流图中的每个节点，建立 Syntax trees。
3. 然后根据 控制流图 来在原本的测试集内选择合适的回归测试用例。



- **Execution Trace**：某个的测试用例在运行的时候在 CFG 中走过的节点的队列

- **Test Vector**：一个 function 的 test vector 就是他的输入值组成的向量

- **Syntax trees**: 抽象语法树是对把源代码按照树状图抽象表示出来

  <img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4b5wq0pkkj30b40cjq3u.jpg" style="zoom:100%" />



##### Method 1: Test Selection

比较 G 和 G' 中相同的节点，如果节点 N 的 Syntex 发生了变化，那么所有 test(N) 都会被添加到新的测试集 T' 中。

##### Method 2:Test Minimization

- Function coverage: 这个方法主要基于从测试集中删除掉与修改部分无关的测试用例来得到新的测试集。而识别哪些该删除基于 testable entities 在原版本中的覆盖率。
- **Testable entities** include, for example, program statements, decisions, def-use chains, etc.

**Steps**

1. 确定需要的  testable entities，比如 function.
2. 运行原测试集 T 中所有的测试用例，观察每个测试用例对  testable entities 的覆盖程度。
3. 保证 每个  testable entities 至少被 minimal subset T' 中的一个测试用例覆盖到。



##### Method 3: Test  Prioritization

Test Minimization 由于是通过删除测试用例得到新的测试集，可能会忽略问题。当要求比较高的时候我们采用 test prioritization 的方法。

Test prioritization 基于优先级选择的原则，对于某个测试用例而言，覆盖的 selected testable entity 越多，那么该测试用例的优先级就越高。

**Steps**

1. 确定需要的  testable entities，比如 function.
2. 运行原测试集 T 中所有的测试用例，观察每个测试用例对  testable entities 的覆盖程度。
3. 根据测试用例的优先级对其进行排序。
4. 排序之后再根据自己的需求来选择测试集。



## 变异测试

### 变异测试的目的

通过生成程序的 mutant 来检测现有的测试用例是否充分，检测未知的问题。

- 充分的测试集：所有的测试用例都能达到 P(t)≠P’(t) 的标准，区分出原程序和变异体。

- **Equivalent**: If there does not exist any test case t in the input domain of P that distinguishes P from P’ then P’ is said to be equivalent to P.

**Adequacy procedure**

1. 对所有的变异体，用测试集 T 进行测试。
2. 对于每个变异体，如果 T 是一个充分的测试集，则表示 killed，如果不充分，则表示 inadequate
3. 1. 如果 inadequate = 0，则代表 T 充分
   2. 如果 inadequate > 0, Mutation Score (MS) = k1(killed)/(k(mutant 总数) - equivalent), *equivalent <= (k - k1) 因为 inadequate 的是能通过部分的，而不是 equivalent*



**Enhancement**

1. 如果 MS < 1，我们需要针对 inadequate 但是并不 equivalent 的 mutant enhance 不能区别变异体的测试用例，使得 mutant 能够被 kill 掉
2. 如果无法 enhance 某个测试用例使得其达成要求，则需要设计一个新的测试用例
3. 然后重新计算 MS，再重复上述步骤

**主要目的是通过变异体来发现当前测试集的不充分，来补充测试集。**

## 嵌入式测试

cache 感觉跟 ICS 里的 locality 内容差不多

- 硬实时和软实时的区别

![img](https://pic1.zhimg.com/80/1fa4a810551ff840158369657d1e0c5d_hd.jpg)

### 全数字模拟测试

采用数学平台的方法,将嵌入式软件从系统中剥离出来,通过开发CPU指令、常用芯片、I/O、 中断、时钟等模拟器在HOST上实现嵌入式软件的测试(*类似让软件跑在虚拟机上*)

有很大的局限性，只能作为辅助手段

### 交叉测试

- 与目标环境无关的部分在 PC 上完成
  - 能够借鉴常规的软件测试方法
  - 与模拟测试不一样
- 与硬件密切相关的部分在 Target 上完成
  - 需要调试环境支持
  - 测试工具需要支持目标环境

### 其他测试

- 静态分析
- 动态测试
- 白盒和黑盒
- 单元和集成
- 先静态后动态
- 先单元后集成
- 先黑盒后白盒

## O-O Test(面向对象测试)

面向对象的测试一般有四层

| 操作/方法测试 | 单元测试      |
| ------------- | ------------- |
| 类测试        | 单元/交互测试 |
| 集成测试      | 集成测试      |
| 系统测试      | 系统测试      |

### 单元测试

可以 以方法为单元，也可以 以类为单元



### 集成测试

通过 UML 图来发现测试的算法

- 顺序图着重体现对象之间消息传递的时间顺序，几乎就是一个完成的 MM-路径

基于 UML 的用例分析

基于 UML 的系统测试